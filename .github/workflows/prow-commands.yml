# GitHub Actions Workflow for Prow Command Handling
# This workflow handles various Prow-style commands on issues and pull requests
# Supports commands like /assign, /kind, /priority, /area, /close, /reopen, etc.
name: Prow Commands

on:
  issue_comment:
    types: [created]

permissions:
  issues: write
  pull-requests: write
  contents: write

jobs:
  handle-command:
    name: Handle Prow Command
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issue_comment' &&
      (startsWith(github.event.comment.body, '/') || contains(github.event.comment.body, '\n/'))

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR details (if applicable)
        id: pr-details
        if: github.event.issue.pull_request
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            core.setOutput('state', pr.data.state);
            core.setOutput('merged', pr.data.merged);
            return pr.data;

      - name: Check user permissions
        id: permissions
        uses: actions/github-script@v7
        with:
          script: |
            const commenter = context.payload.comment.user.login;

            // Check if user is org member
            let isOrgMember = false;
            let isMaintainer = false;

            try {
              const membership = await github.rest.orgs.checkMembershipForUser({
                org: context.repo.owner,
                username: commenter
              });
              isOrgMember = membership.status === 204;
            } catch (error) {
              // Not an org member or public member
              isOrgMember = false;
            }

            // Check if user has write access (maintainer)
            try {
              const permission = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: commenter
              });
              isMaintainer = ['admin', 'write'].includes(permission.data.permission);
            } catch (error) {
              isMaintainer = false;
            }

            core.setOutput('is_org_member', isOrgMember);
            core.setOutput('is_maintainer', isMaintainer);
            core.setOutput('commenter', commenter);

            return { isOrgMember, isMaintainer, commenter };

      - name: Process Commands
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment.body;
            const issueNumber = context.issue.number;
            const isOrgMember = '${{ steps.permissions.outputs.is_org_member }}' === 'true';
            const isMaintainer = '${{ steps.permissions.outputs.is_maintainer }}' === 'true';
            const commenter = '${{ steps.permissions.outputs.commenter }}';
            const isPR = !!context.payload.issue.pull_request;

            // Extract all commands from the comment
            const commands = comment.split('\n')
              .map(line => line.trim())
              .filter(line => line.startsWith('/'));

            console.log('Found commands:', commands);

            let reactions = [];
            let responses = [];

            for (const cmd of commands) {
              const parts = cmd.split(/\s+/);
              const command = parts[0].toLowerCase();
              const args = parts.slice(1);

              console.log(`Processing command: ${command} with args:`, args);

              // /assign command - assign users to issue/PR
              if (command === '/assign') {
                if (!isOrgMember) {
                  responses.push('You must be an organization member to use `/assign`');
                  continue;
                }

                const assignees = args.length > 0
                  ? args.map(u => u.replace('@', ''))
                  : [commenter];

                try {
                  await github.rest.issues.addAssignees({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    assignees: assignees
                  });
                  responses.push(`Assigned to: ${assignees.map(u => '@' + u).join(', ')}`);
                  reactions.push('+1');
                } catch (error) {
                  responses.push(`Failed to assign: ${error.message}`);
                }
              }

              // /unassign command - remove assignees
              else if (command === '/unassign') {
                if (!isOrgMember) {
                  responses.push('You must be an organization member to use `/unassign`');
                  continue;
                }

                const assignees = args.length > 0
                  ? args.map(u => u.replace('@', ''))
                  : [commenter];

                try {
                  await github.rest.issues.removeAssignees({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    assignees: assignees
                  });
                  responses.push(`Unassigned: ${assignees.map(u => '@' + u).join(', ')}`);
                  reactions.push('eyes');
                } catch (error) {
                  responses.push(`Failed to unassign: ${error.message}`);
                }
              }

              // /kind command - set issue/PR type
              else if (command === '/kind') {
                if (!isOrgMember) {
                  responses.push('You must be an organization member to use `/kind`');
                  continue;
                }

                if (args.length === 0) {
                  responses.push('Usage: `/kind <type>` where type is one of: bug, feature, enhancement, documentation, question, cleanup, security, performance');
                  continue;
                }

                const kind = args[0].toLowerCase();
                const validKinds = ['bug', 'feature', 'enhancement', 'documentation', 'question', 'cleanup', 'security', 'performance'];

                if (!validKinds.includes(kind)) {
                  responses.push(`Invalid kind. Valid options: ${validKinds.join(', ')}`);
                  continue;
                }

                const label = `kind/${kind}`;

                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    labels: [label]
                  });
                  responses.push(`Added label: \`${label}\``);
                  reactions.push('+1');
                } catch (error) {
                  responses.push(`Failed to add label: ${error.message}`);
                }
              }

              // /priority command - set priority level
              else if (command === '/priority') {
                if (!isOrgMember) {
                  responses.push('You must be an organization member to use `/priority`');
                  continue;
                }

                if (args.length === 0) {
                  responses.push('Usage: `/priority <level>` where level is one of: p0, p1, p2, p3');
                  continue;
                }

                const priority = args[0].toLowerCase();
                const validPriorities = ['p0', 'p1', 'p2', 'p3'];

                if (!validPriorities.includes(priority)) {
                  responses.push(`Invalid priority. Valid options: ${validPriorities.join(', ')}`);
                  continue;
                }

                const label = `priority/${priority}`;

                try {
                  // Remove existing priority labels
                  const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber
                  });

                  for (const currentLabel of currentLabels) {
                    if (currentLabel.name.startsWith('priority/')) {
                      await github.rest.issues.removeLabel({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber,
                        name: currentLabel.name
                      });
                    }
                  }

                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    labels: [label]
                  });
                  responses.push(`Set priority: \`${label}\``);
                  reactions.push('+1');
                } catch (error) {
                  responses.push(`Failed to set priority: ${error.message}`);
                }
              }

              // /area command - set component/area
              else if (command === '/area') {
                if (!isOrgMember) {
                  responses.push('You must be an organization member to use `/area`');
                  continue;
                }

                if (args.length === 0) {
                  responses.push('Usage: `/area <name>` where name is one of: api, auth, database, frontend, storage, testing, ci-cd, documentation, security');
                  continue;
                }

                const area = args[0].toLowerCase();
                const validAreas = ['api', 'auth', 'database', 'frontend', 'storage', 'testing', 'ci-cd', 'documentation', 'security'];

                if (!validAreas.includes(area)) {
                  responses.push(`Invalid area. Valid options: ${validAreas.join(', ')}`);
                  continue;
                }

                const label = `area/${area}`;

                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    labels: [label]
                  });
                  responses.push(`Added area: \`${label}\``);
                  reactions.push('+1');
                } catch (error) {
                  responses.push(`Failed to add area: ${error.message}`);
                }
              }

              // /close command - close issue/PR
              else if (command === '/close') {
                if (!isMaintainer && commenter !== context.payload.issue.user.login) {
                  responses.push('Only maintainers or the issue author can close issues');
                  continue;
                }

                try {
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    state: 'closed'
                  });
                  responses.push('Closed');
                  reactions.push('rocket');
                } catch (error) {
                  responses.push(`Failed to close: ${error.message}`);
                }
              }

              // /reopen command - reopen issue/PR
              else if (command === '/reopen') {
                if (!isMaintainer) {
                  responses.push('Only maintainers can reopen issues');
                  continue;
                }

                try {
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    state: 'open'
                  });
                  responses.push('Reopened');
                  reactions.push('eyes');
                } catch (error) {
                  responses.push(`Failed to reopen: ${error.message}`);
                }
              }

              // /hold command - prevent merge
              else if (command === '/hold') {
                if (!isPR) {
                  responses.push('`/hold` can only be used on pull requests');
                  continue;
                }

                if (!isMaintainer) {
                  responses.push('Only maintainers can use `/hold`');
                  continue;
                }

                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    labels: ['do-not-merge/hold']
                  });
                  responses.push('PR is on hold - will not be merged');
                  reactions.push('stop_sign');
                } catch (error) {
                  responses.push(`Failed to hold PR: ${error.message}`);
                }
              }

              // /unhold command - allow merge
              else if (command === '/unhold') {
                if (!isPR) {
                  responses.push('`/unhold` can only be used on pull requests');
                  continue;
                }

                if (!isMaintainer) {
                  responses.push('Only maintainers can use `/unhold`');
                  continue;
                }

                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    name: 'do-not-merge/hold'
                  });
                  responses.push('Hold removed - PR can be merged');
                  reactions.push('+1');
                } catch (error) {
                  responses.push(`Failed to unhold PR: ${error.message}`);
                }
              }

              // /approve command - approve PR
              else if (command === '/approve') {
                if (!isPR) {
                  responses.push('`/approve` can only be used on pull requests');
                  continue;
                }

                if (!isMaintainer) {
                  responses.push('Only maintainers can approve PRs');
                  continue;
                }

                try {
                  await github.rest.pulls.createReview({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: issueNumber,
                    event: 'APPROVE',
                    body: 'Approved via `/approve` command'
                  });

                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    labels: ['approved']
                  });

                  responses.push('PR approved');
                  reactions.push('heart');
                } catch (error) {
                  responses.push(`Failed to approve: ${error.message}`);
                }
              }

              // /lgtm command - mark as looks good to me
              else if (command === '/lgtm') {
                if (!isPR) {
                  responses.push('`/lgtm` can only be used on pull requests');
                  continue;
                }

                if (!isOrgMember) {
                  responses.push('You must be an organization member to use `/lgtm`');
                  continue;
                }

                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    labels: ['lgtm']
                  });
                  responses.push('LGTM - Looks good to me!');
                  reactions.push('+1');
                } catch (error) {
                  responses.push(`Failed to add LGTM: ${error.message}`);
                }
              }

              // /ready command - mark PR as ready for review
              else if (command === '/ready') {
                if (!isPR) {
                  responses.push('`/ready` can only be used on pull requests');
                  continue;
                }

                try {
                  // Remove WIP label if exists
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      name: 'do-not-merge/work-in-progress'
                    });
                  } catch (e) {
                    // Label might not exist
                  }

                  // Convert from draft if applicable
                  const pr = await github.rest.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: issueNumber
                  });

                  if (pr.data.draft) {
                    await github.rest.pulls.update({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: issueNumber,
                      draft: false
                    });
                  }

                  responses.push('PR is ready for review');
                  reactions.push('rocket');
                } catch (error) {
                  responses.push(`Failed to mark as ready: ${error.message}`);
                }
              }

              // /needs-info command - request more information
              else if (command === '/needs-info') {
                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    labels: ['needs-info']
                  });
                  responses.push('Marked as needing more information');
                  reactions.push('thinking_face');
                } catch (error) {
                  responses.push(`Failed to add label: ${error.message}`);
                }
              }

              // /good-first-issue command - mark as good for newcomers
              else if (command === '/good-first-issue') {
                if (!isMaintainer) {
                  responses.push('Only maintainers can mark issues as good first issues');
                  continue;
                }

                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    labels: ['good-first-issue']
                  });
                  responses.push('Marked as good first issue');
                  reactions.push('tada');
                } catch (error) {
                  responses.push(`Failed to add label: ${error.message}`);
                }
              }

              // /help command - show available commands
              else if (command === '/help') {
                const helpText = `## Available Prow Commands

### Anyone
- \`/needs-info\` - Mark as needing more information
- \`/retest\` - Rerun all failing CI jobs (see separate workflow)
- \`/test <job>\` - Run specific CI job (see separate workflow)

### Organization Members
- \`/assign [@user]\` - Assign issue/PR (defaults to self if no user specified)
- \`/unassign [@user]\` - Remove assignee
- \`/kind <type>\` - Set type: bug, feature, enhancement, documentation, question, cleanup, security, performance
- \`/area <name>\` - Set area: api, auth, database, frontend, storage, testing, ci-cd, documentation, security
- \`/priority <level>\` - Set priority: p0 (critical), p1 (high), p2 (medium), p3 (low)
- \`/lgtm\` - Mark PR as "looks good to me"

### Maintainers/Admins
- \`/approve\` - Approve PR
- \`/hold\` - Prevent PR from being merged
- \`/unhold\` - Remove merge hold
- \`/close\` - Close issue/PR
- \`/reopen\` - Reopen issue/PR
- \`/good-first-issue\` - Mark as good for newcomers

### PR Author or Maintainer
- \`/ready\` - Mark PR as ready for review (removes WIP status)

For more information, see the [Contributing Guide](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/CONTRIBUTING.md).`;

                responses.push(helpText);
                reactions.push('book');
              }

              // Unknown command
              else {
                responses.push(`Unknown command: \`${command}\`. Use \`/help\` to see available commands.`);
              }
            }

            // Add reactions to the comment
            for (const reaction of [...new Set(reactions)]) {
              try {
                await github.rest.reactions.createForIssueComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: context.payload.comment.id,
                  content: reaction
                });
              } catch (error) {
                console.log(`Failed to add reaction ${reaction}:`, error.message);
              }
            }

            // Post response comment if there are responses
            if (responses.length > 0) {
              const responseBody = responses.join('\n\n');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: responseBody
              });
            }
